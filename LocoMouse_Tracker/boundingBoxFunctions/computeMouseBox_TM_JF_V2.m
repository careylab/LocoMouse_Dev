function [box, CC, I_crop,Ibw] = computeMouseBox_TM_JF(I,split_line,threshold)

% COMPUTEMOUSEBOX in its different version computes the bounding box around 
% the mouse on a background subtracted image.
% Different setups may demand adjustments.
%
% This script is adapted to be used with a head-free treadmill setup.
%
% !!DO NOT EDIT THIS FILE!! - unless you are the original author.
% FOLLOW INSTRUCTIONS IN "READ_BEFORE_CHANGING_ANYTHING.m"
%
% INPUT:
% I: background subtracted grayscale image.
% split_line: pixel hight dividing the two views.
%
% OUTPUT: 
% - bounding box: a 2x3 matrix for 
%              [br_x    br_yb      br_yt; ...
%               width   height_b   height_t];
%                   with
%                   br_x    = x of bottom right corner
%                   br_yb   = y of bottom half of the image (bottom view)
%                   br_yt   = y of top half of the image (lateral view)
%                   width   = width
%                   height_b= height in bottom half of the image
%                   height_t= height in top half of the image
%                   Cordinates refer to the image halves *after cutting*. 
%                   In whole image br_yt needs to be added to the split line.
%
% - cc:     2x2 matrix where the i-th column is the 2x1 image coordinates 
%           of the centroid of the bounding in view i (i == 1 is bottom). 
% - I_crop: 2x1 cell with the bottom and top view cropped images.
%
% TREADMILL SPECIFICS:
%   [1] In this script the object detection is exclusively done on the lateral
%       view, because the view through the treadmill makes it very difficult.
%   [2] Due to additional noise around the edges, the side view is padded
%       in a black frame
%   [3] The bounding box width is hardcoded.
%   [4] The final box only uses the bottom right corner of the detected
%       object.
%
% DON'T EDIT THIS FUNCTION, MAKE A COPY AND FOLLOW
%                                         "READ_BEFORE_CHANGING_ANYTHING.m"
%   0. Check different existing functions to find the one that gives you the
%      best result and modify that function.
%   1. Save changes into a copy replacing 'DE' with your initials and
%      change the function name appropriately.
%   2. Ensure the OUTPUT remains in the format described above.
%   3. Comment your changes to allow the next person to understand what you
%      did.
% ------------------------------------------
% DE rewriting Dana's computeMouseBoxNewTest
% ------------------------------------------

if ~exist('threshold','var')
    threshold = [0.05 0.05]; % [side bottom]
elseif length(threshold) == 1 % if only one threshold is set, 
    threshold = [threshold threshold]; % use same threshold for bottom and side view
end

% Fixed parameters:
BB_WIDTH = 400;
WIDTH_MARGIN = 0.10;
CC = [];
MIN_VIS_PIXEL = 10;

% Setup dependent parameters: These are hardcoded by setup creators:
BB_LEFT_MARGIN = 100;
BB_RIGHT_MARGIN = 150;
BB_TOP_MARGIN = 46;
BB_BOTTOM_MARGIN = 761;

[I_crop{[1 2]}] = splitImage(I,split_line);
    ti = 1;
% [1] for ti = [1 2] this script only uses the side view to determine the box
    I_crop_bw{ti}=imadjust(I_crop{ti});  % brightness and contrast optimization
% [2] [Start] Dana special: padding with a black frame
    
    Ibw = im2bw(I_crop_bw{ti},threshold(ti));
    Ibw = medfilt2(Ibw,[11 11]);
    Ibw(1:BB_LEFT_MARGIN,:) = 0;
    Ibw(BB_RIGHT_MARGIN:end,:) = 0;
    Ibw(:,1:BB_TOP_MARGIN,:) = 0;
    Ibw(:,BB_BOTTOM_MARGIN:end) = 0;

if ~isempty(any(Ibw(:)))
    
    % Sum white pixels along row and column to get a "projection" of the
    % mouse
    reduce_row = movsum(sum(Ibw,1),BB_WIDTH);
    
%     reduce_col = sum(Ibw,2);
    
    % Find rightmost column that sums to more than 10 pixels and add a 5%
    % margin so long as we are within image bounds:
    
    
    
    [~,mid] = max(reduce_row);
    tX = min(mid + (WIDTH_MARGIN+0.5)*BB_WIDTH,size(I,2));
    
    % Find the first and last rows to sum to more than 20 pixels and add a
    % 10% margin 
%     reduce_row_10 = reduce_col > 20;
%     col_first = find(reduce_row_10, 1, 'first');
%     col_last = find(reduce_row_10 ,1, 'last');
%     
%     height_side = min((col_last - col_first + 1) * 1.1, size(I_crop{ti},1));

    height_side = size(I_crop{2},1);
    
    if BB_WIDTH >= tX
        BB_WIDTH=tX-1;
    end
    box=[   tX,     size(I_crop{2},1)-1,    size(I_crop{1},1)-1;...
            BB_WIDTH,	size(I_crop{2},1)-1,      height_side];
else
    box=   NaN(2,3);
end
 
box = round(box);

end

