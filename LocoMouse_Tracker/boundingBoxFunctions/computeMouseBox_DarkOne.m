function [box, cc, I_crop] = computeMouseBox_DarkOne(I,split_line,threshold)

% COMPUTEMOUSEBOX in its different version computes the bounding box around 
% the mouse on a background subtracted image.
% Different setups may demand adjustments.
%
% This script is adapted to be used with a head-free treadmill setup 
% under INFRARED conditions.
%
% !!DO NOT EDIT THIS FILE!! - unless you are the original author.
% FOLLOW INSTRUCTIONS IN "READ_BEFORE_CHANGING_ANYTHING.m"
%
% INPUT:
% I: background subtracted grayscale image.
% split_line: pixel height dividing the two views.
%
% OUTPUT: 
% - bounding box: a 2x3 matrix for 
%              [br_x    br_yb      br_yt; ...
%               width   height_b   height_t];
                %   with
                %   br_x    = x of bottom right corner
                %   br_yb   = y of bottom half of the image (bottom view)
                %   br_yt   = y of top half of the image (lateral view)
                %   width   = width
                %   height_b= height in bottom half of the image
                %   height_t= height in top half of the image
%               Cordinates refer to the image halves *after cutting*. 
%               In whole image br_yt needs to be added to the split line.
%
% - cc:     2x2 matrix where the i-th column is the 2x1 image coordinates 
%           of the centroid of the bounding in view i (i == 1 is bottom). 
% - I_crop: 2x1 cell with the bottom and top view cropped images.
%
% TREADMILL SPECIFICS:
%   [1] In this script the object detection is exclusively done on the lateral
%       view, because the view through the treadmill makes it very difficult.
%   [2] Due to additional noise around the edges, the side view is padded
%       in a black frame
%   [3] The bounding box width is hardcoded.
%   [4] The final box only uses the bottom right corner of the detected
%       object.
%
% DON'T EDIT THIS FUNCTION, MAKE A COPY AND FOLLOW
%                                         "READ_BEFORE_CHANGING_ANYTHING.m"
%   0. Check different existing functions to find the one that gives you the
%      best result and modify that function.
%   1. Save changes into a copy replacing 'DE' with your initials and
%      change the function name appropriately.
%   2. Ensure the OUTPUT remains in the format described above.
%   3. Comment your changes to allow the next person to understand what you
%      did.
% ------------------------------------------
% DE - for DarkOne
% ------------------------------------------

if ~exist('threshold','var')
    threshold = [0.01 0.01]; % [side bottom]
elseif length(threshold) == 1 % if only one threshold is set, 
    threshold = [threshold threshold]; % use same threshold for bottom and side view
end

    Height = size(I,1);
	Width = size(I,2);
    H = fspecial('disk',6);
    [I_crop{[1 2]}] = splitImage(I,split_line);
    for tci = 1:2
        
        I_crop_bw{tci} = imfill(imfilter(bwareaopen(im2bw(I_crop{tci},0.01),500),H,'replicate'),'holes');
        cc = bwconncomp(I_crop_bw{tci}); % finds connected objects

        % largest_object: idx of the object with most pixels
        [~,largest_object] = max(cellfun(@(x)(length(x)),cc.PixelIdxList)); 
        % remakeing the bw image to only show the largest_object:
        I_crop_bw{tci} = false(size(I_crop_bw{tci})); 
        I_crop_bw{tci}(cc.PixelIdxList{largest_object}) = true;

        % Get bounding box for the largest object:
        bbox{tci}=regionprops( I_crop_bw{tci},'BoundingBox');
        objs{tci}=vertcat(bbox{tci}.BoundingBox); % [upper_left_X, upper_left_Y width height]

    end
    
	% Obj{2} bottom  [upper_left_X, upper_left_Y width height]
	% Obj{1} is side [upper_left_X, upper_left_Y width height]
    imshow(I)
    hold on
    rectangle('Position',objs{1},'EdgeColor','w')
    rectangle('Position',[objs{2}(1) objs{2}(2)+split_line objs{2}(3:4)],'EdgeColor','w')
    hold off
    
    BRC_x = objs{1}(1)+objs{1}(3); % bottom right corner in x 
    if BRC_x >= size(I,2)
        BRC_x = size(I,2)-1;
    end
    
	BRC_yb = objs{2}(2)+objs{2}(4); % bottom view cropped image y
    if BRC_yb <1
        BRC_yb = 1;
    elseif BRC_yb >= Height - split_line
        BRC_yb = Height - split_line - 1;
    end
    
	BRC_yt = objs{1}(2)+objs{1}(4); % side view cropped image y
    if BRC_yt <1
        BRC_yt = 1;
    elseif BRC_yt >= split_line
        BRC_yt = split_line - 1;
    end

	width_im = min([objs{1}(3) objs{2}(3)]); % total width of image
	height_b = BRC_yb-1; % height of bottom view
	height_t = objs{1}(4)-1; % height of side view
    
    box =floor([BRC_x      BRC_yb      BRC_yt; ...
                width_im    height_b    height_t]);
    CC = [];
    
end

